// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\whdlOFDMTransmitter_up_con\OFDM_UC_tb.v
// Created: 2023-03-08 15:39:49
// 
// Generated by MATLAB 9.13 and HDL Coder 4.0
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 2.44141e-07
// Target subsystem base rate: 2.44141e-07
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out_1      4.88281e-07
// ce_out_0      7.8125e-06
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// txValid                       ce_out_0      7.8125e-06
// txData_re                     ce_out_0      7.8125e-06
// txData_im                     ce_out_0      7.8125e-06
// Out3                          ce_out_0      7.8125e-06
// Out4_re                       ce_out_0      7.8125e-06
// Out4_im                       ce_out_0      7.8125e-06
// ready                         ce_out_1      4.88281e-07
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: OFDM_UC_tb
// Source Path: 
// Hierarchy Level: 0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module OFDM_UC_tb;



  reg  clk;
  reg  reset;
  wire clk_enable;
  wire ready_done;  // ufix1
  wire ce_out_1;
  wire ready_done_enb;  // ufix1
  reg [17:0] ready_addr;  // ufix18
  wire ready_active;  // ufix1
  wire ready_enb;  // ufix1
  wire ready_lastAddr;  // ufix1
  wire resetn;
  reg  check5_done;  // ufix1
  wire Out4_re_done;  // ufix1
  wire ce_out_0;
  wire Out4_re_done_enb;  // ufix1
  reg [13:0] txValid_addr;  // ufix14
  wire Out4_re_lastAddr;  // ufix1
  reg  check4_done;  // ufix1
  wire Out3_done;  // ufix1
  wire Out3_done_enb;  // ufix1
  wire Out3_lastAddr;  // ufix1
  reg  check3_done;  // ufix1
  wire txData_re_done;  // ufix1
  wire txData_re_done_enb;  // ufix1
  wire txData_re_lastAddr;  // ufix1
  reg  check2_done;  // ufix1
  wire txValid_done;  // ufix1
  wire txValid_done_enb;  // ufix1
  wire txValid_active;  // ufix1
  reg [17:0] Data_Type_Conversion5_out1_addr;  // ufix18
  wire [17:0] Data_Type_Conversion1_out1_addr_delay_1;  // ufix18
  reg  tb_enb_delay;
  wire phase_2_valid;
  reg signed [31:0] fp_valid;  // sfix32
  reg  rawData_valid;
  reg signed [31:0] status_valid;  // sfix32
  reg  holdData_valid;
  reg  valid_offset;
  wire valid;
  wire [17:0] Data_Type_Conversion3_out1_addr_delay_1;  // ufix18
  reg signed [31:0] fp_data;  // sfix32
  reg  rawData_data;
  reg signed [31:0] status_data;  // sfix32
  reg  holdData_data;
  reg  data_offset;
  wire data;
  wire [17:0] Data_Type_Conversion2_out1_addr_delay_1;  // ufix18
  reg signed [31:0] fp_codeRateIndex;  // sfix32
  reg [1:0] rawData_codeRateIndex;  // ufix2
  reg signed [31:0] status_codeRateIndex;  // sfix32
  reg [1:0] holdData_codeRateIndex;  // ufix2
  reg [1:0] codeRateIndex_offset;  // ufix2
  wire [1:0] codeRateIndex;  // ufix2
  wire Data_Type_Conversion5_out1_active;  // ufix1
  reg [4:0] counter;  // ufix5
  wire phase_2_all;
  wire phase_2;
  wire Data_Type_Conversion5_out1_enb;  // ufix1
  wire [17:0] Data_Type_Conversion5_out1_addr_delay_1;  // ufix18
  reg signed [31:0] fp_modTypeIndex;  // sfix32
  reg [1:0] rawData_modTypeIndex;  // ufix2
  reg signed [31:0] status_modTypeIndex;  // sfix32
  reg [1:0] holdData_modTypeIndex;  // ufix2
  reg [1:0] modTypeIndex_offset;  // ufix2
  wire [1:0] modTypeIndex;  // ufix2
  wire snkDone;
  wire snkDonen;
  wire tb_enb;
  wire notDone;
  wire txValid;
  wire signed [15:0] txData_re;  // sfix16_En13
  wire signed [15:0] txData_im;  // sfix16_En13
  wire Out3;
  wire signed [17:0] Out4_re;  // sfix18_En16
  wire signed [17:0] Out4_im;  // sfix18_En16
  wire ready;
  wire txValid_enb;  // ufix1
  wire txValid_lastAddr;  // ufix1
  reg  check1_done;  // ufix1
  wire [13:0] txValid_addr_delay_1;  // ufix14
  reg signed [31:0] fp_txValid_expected;  // sfix32
  reg  txValid_expected;
  reg signed [31:0] status_txValid_expected;  // sfix32
  reg  txValid_ref_hold;
  wire txValid_refTmp;
  wire txValid_ref;
  reg  txValid_testFailure;  // ufix1
  wire [13:0] txData_re_addr_delay_1;  // ufix14
  reg signed [31:0] fp_txData_re_expected;  // sfix32
  reg signed [15:0] txData_re_expected;  // sfix16_En13
  reg signed [31:0] status_txData_re_expected;  // sfix32
  reg signed [15:0] txData_re_ref_hold;  // sfix16_En13
  wire signed [15:0] txData_re_refTmp;  // sfix16_En13
  wire signed [15:0] txData_re_ref;  // sfix16_En13
  reg  txData_re_testFailure;  // ufix1
  reg signed [31:0] fp_txData_im_expected;  // sfix32
  reg signed [15:0] txData_im_expected;  // sfix16_En13
  reg signed [31:0] status_txData_im_expected;  // sfix32
  reg signed [15:0] txData_im_ref_hold;  // sfix16_En13
  wire signed [15:0] txData_im_refTmp;  // sfix16_En13
  wire signed [15:0] txData_im_ref;  // sfix16_En13
  reg  txData_im_testFailure;  // ufix1
  wire [13:0] Out3_addr_delay_1;  // ufix14
  reg signed [31:0] fp_Out3_expected;  // sfix32
  reg  Out3_expected;
  reg signed [31:0] status_Out3_expected;  // sfix32
  reg  Out3_ref_hold;
  wire Out3_refTmp;
  wire Out3_ref;
  reg  Out3_testFailure;  // ufix1
  wire [13:0] Out4_re_addr_delay_1;  // ufix14
  reg signed [31:0] fp_Out4_re_expected;  // sfix32
  reg signed [17:0] Out4_re_expected;  // sfix18_En16
  reg signed [31:0] status_Out4_re_expected;  // sfix32
  reg signed [17:0] Out4_re_ref_hold;  // sfix18_En16
  wire signed [17:0] Out4_re_refTmp;  // sfix18_En16
  wire signed [17:0] Out4_re_ref;  // sfix18_En16
  reg  Out4_re_testFailure;  // ufix1
  reg signed [31:0] fp_Out4_im_expected;  // sfix32
  reg signed [17:0] Out4_im_expected;  // sfix18_En16
  reg signed [31:0] status_Out4_im_expected;  // sfix32
  reg signed [17:0] Out4_im_ref_hold;  // sfix18_En16
  wire signed [17:0] Out4_im_refTmp;  // sfix18_En16
  wire signed [17:0] Out4_im_ref;  // sfix18_En16
  reg  Out4_im_testFailure;  // ufix1
  wire [17:0] ready_addr_delay_1;  // ufix18
  reg signed [31:0] fp_ready_expected;  // sfix32
  reg  ready_expected;
  reg signed [31:0] status_ready_expected;  // sfix32
  reg  ready_ref_hold;
  wire ready_refTmp;
  wire ready_ref;
  reg  ready_testFailure;  // ufix1
  wire testFailure;  // ufix1


  assign ready_done_enb = ready_done & ce_out_1;



  assign ready_active = ready_addr != 18'b110001011101110000;



  assign ready_enb = ce_out_1 & ready_active;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 202608
  always @(posedge clk or posedge reset)
    begin : c_process
      if (reset == 1'b1) begin
        ready_addr <= 18'b000000000000000000;
      end
      else begin
        if (ready_enb) begin
          if (ready_addr >= 18'b110001011101110000) begin
            ready_addr <= 18'b000000000000000000;
          end
          else begin
            ready_addr <= ready_addr + 18'b000000000000000001;
          end
        end
      end
    end



  assign ready_lastAddr = ready_addr >= 18'b110001011101110000;



  assign ready_done = ready_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_5
      if (reset) begin
        check5_done <= 0;
      end
      else begin
        if (ready_done_enb) begin
          check5_done <= ready_done;
        end
      end
    end

  assign Out4_re_done_enb = Out4_re_done & ce_out_0;



  assign Out4_re_lastAddr = txValid_addr >= 14'b11000101110111;



  assign Out4_re_done = Out4_re_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_4
      if (reset) begin
        check4_done <= 0;
      end
      else begin
        if (Out4_re_done_enb) begin
          check4_done <= Out4_re_done;
        end
      end
    end

  assign Out3_done_enb = Out3_done & ce_out_0;



  assign Out3_lastAddr = txValid_addr >= 14'b11000101110111;



  assign Out3_done = Out3_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_3
      if (reset) begin
        check3_done <= 0;
      end
      else begin
        if (Out3_done_enb) begin
          check3_done <= Out3_done;
        end
      end
    end

  assign txData_re_done_enb = txData_re_done & ce_out_0;



  assign txData_re_lastAddr = txValid_addr >= 14'b11000101110111;



  assign txData_re_done = txData_re_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_2
      if (reset) begin
        check2_done <= 0;
      end
      else begin
        if (txData_re_done_enb) begin
          check2_done <= txData_re_done;
        end
      end
    end

  assign txValid_done_enb = txValid_done & ce_out_0;



  assign txValid_active = txValid_addr != 14'b11000101110111;



  assign #1 Data_Type_Conversion1_out1_addr_delay_1 = Data_Type_Conversion5_out1_addr;

  // Data source for valid
  initial
    begin : valid_fileread
      fp_valid = $fopen("valid.dat", "r");
      status_valid = $rewind(fp_valid);
    end

  always @(Data_Type_Conversion1_out1_addr_delay_1, phase_2_valid, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        rawData_valid <= 1'bx;
      end
      else if (phase_2_valid == 1) begin
        status_valid = $fscanf(fp_valid, "%h", rawData_valid);
      end
    end

  // holdData reg for Data_Type_Conversion1_out1
  always @(posedge clk or posedge reset)
    begin : stimuli_Data_Type_Conversion1_out1
      if (reset) begin
        holdData_valid <= 1'bx;
      end
      else begin
        holdData_valid <= rawData_valid;
      end
    end

  always @(rawData_valid or phase_2_valid)
    begin : stimuli_Data_Type_Conversion1_out1_1
      if (phase_2_valid == 1'b0) begin
        valid_offset <= holdData_valid;
      end
      else begin
        valid_offset <= rawData_valid;
      end
    end

  assign #2 valid = valid_offset;

  assign #1 Data_Type_Conversion3_out1_addr_delay_1 = Data_Type_Conversion5_out1_addr;

  // Data source for data
  initial
    begin : data_fileread
      fp_data = $fopen("data.dat", "r");
      status_data = $rewind(fp_data);
    end

  always @(Data_Type_Conversion3_out1_addr_delay_1, phase_2_valid, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        rawData_data <= 1'bx;
      end
      else if (phase_2_valid == 1) begin
        status_data = $fscanf(fp_data, "%h", rawData_data);
      end
    end

  // holdData reg for Data_Type_Conversion3_out1
  always @(posedge clk or posedge reset)
    begin : stimuli_Data_Type_Conversion3_out1
      if (reset) begin
        holdData_data <= 1'bx;
      end
      else begin
        holdData_data <= rawData_data;
      end
    end

  always @(rawData_data or phase_2_valid)
    begin : stimuli_Data_Type_Conversion3_out1_1
      if (phase_2_valid == 1'b0) begin
        data_offset <= holdData_data;
      end
      else begin
        data_offset <= rawData_data;
      end
    end

  assign #2 data = data_offset;

  assign #1 Data_Type_Conversion2_out1_addr_delay_1 = Data_Type_Conversion5_out1_addr;

  // Data source for codeRateIndex
  initial
    begin : codeRateIndex_fileread
      fp_codeRateIndex = $fopen("codeRateIndex.dat", "r");
      status_codeRateIndex = $rewind(fp_codeRateIndex);
    end

  always @(Data_Type_Conversion2_out1_addr_delay_1, phase_2_valid, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        rawData_codeRateIndex <= 2'bx;
      end
      else if (phase_2_valid == 1) begin
        status_codeRateIndex = $fscanf(fp_codeRateIndex, "%h", rawData_codeRateIndex);
      end
    end

  // holdData reg for Data_Type_Conversion2_out1
  always @(posedge clk or posedge reset)
    begin : stimuli_Data_Type_Conversion2_out1
      if (reset) begin
        holdData_codeRateIndex <= 2'bx;
      end
      else begin
        holdData_codeRateIndex <= rawData_codeRateIndex;
      end
    end

  always @(rawData_codeRateIndex or phase_2_valid)
    begin : stimuli_Data_Type_Conversion2_out1_1
      if (phase_2_valid == 1'b0) begin
        codeRateIndex_offset <= holdData_codeRateIndex;
      end
      else begin
        codeRateIndex_offset <= rawData_codeRateIndex;
      end
    end

  assign #2 codeRateIndex = codeRateIndex_offset;

  assign Data_Type_Conversion5_out1_active = Data_Type_Conversion5_out1_addr != 18'b110001011101110000;



  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 31
  always @(posedge clk or posedge reset)
    begin : slow_clock_enable_process
      if (reset == 1'b1) begin
        counter <= 5'b00001;
      end
      else begin
        if (tb_enb_delay) begin
          counter <= counter + 5'b00001;
        end
      end
    end



  assign phase_2_all = counter % 2 == 1;

  assign phase_2_valid = phase_2_all & tb_enb_delay;



  assign phase_2 = phase_2_valid;

  assign Data_Type_Conversion5_out1_enb = Data_Type_Conversion5_out1_active & (phase_2 & tb_enb_delay);



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 202608
  always @(posedge clk or posedge reset)
    begin : DataTypeConversion5_process
      if (reset == 1'b1) begin
        Data_Type_Conversion5_out1_addr <= 18'b000000000000000000;
      end
      else begin
        if (Data_Type_Conversion5_out1_enb) begin
          if (Data_Type_Conversion5_out1_addr >= 18'b110001011101110000) begin
            Data_Type_Conversion5_out1_addr <= 18'b000000000000000000;
          end
          else begin
            Data_Type_Conversion5_out1_addr <= Data_Type_Conversion5_out1_addr + 18'b000000000000000001;
          end
        end
      end
    end



  assign #1 Data_Type_Conversion5_out1_addr_delay_1 = Data_Type_Conversion5_out1_addr;

  // Data source for modTypeIndex
  initial
    begin : modTypeIndex_fileread
      fp_modTypeIndex = $fopen("modTypeIndex.dat", "r");
      status_modTypeIndex = $rewind(fp_modTypeIndex);
    end

  always @(Data_Type_Conversion5_out1_addr_delay_1, phase_2_valid, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        rawData_modTypeIndex <= 2'bx;
      end
      else if (phase_2_valid == 1) begin
        status_modTypeIndex = $fscanf(fp_modTypeIndex, "%h", rawData_modTypeIndex);
      end
    end

  // holdData reg for Data_Type_Conversion5_out1
  always @(posedge clk or posedge reset)
    begin : stimuli_Data_Type_Conversion5_out1
      if (reset) begin
        holdData_modTypeIndex <= 2'bx;
      end
      else begin
        holdData_modTypeIndex <= rawData_modTypeIndex;
      end
    end

  always @(rawData_modTypeIndex or phase_2_valid)
    begin : stimuli_Data_Type_Conversion5_out1_1
      if (phase_2_valid == 1'b0) begin
        modTypeIndex_offset <= holdData_modTypeIndex;
      end
      else begin
        modTypeIndex_offset <= rawData_modTypeIndex;
      end
    end

  assign #2 modTypeIndex = modTypeIndex_offset;

  assign snkDonen =  ~ snkDone;



  assign resetn =  ~ reset;



  assign tb_enb = resetn & snkDonen;



  // Delay inside enable generation: register depth 1
  always @(posedge clk or posedge reset)
    begin : u_enable_delay
      if (reset) begin
        tb_enb_delay <= 0;
      end
      else begin
        tb_enb_delay <= tb_enb;
      end
    end

  assign notDone = tb_enb_delay & snkDonen;



  assign #2 clk_enable = notDone;

  initial
    begin : reset_gen
      reset <= 1'b1;
      # (20);
      @ (posedge clk)
      # (2);
      reset <= 1'b0;
    end

  always 
    begin : clk_gen
      clk <= 1'b1;
      # (5);
      clk <= 1'b0;
      # (5);
      if (snkDone == 1'b1) begin
        clk <= 1'b1;
        # (5);
        clk <= 1'b0;
        # (5);
        $stop;
      end
    end

  OFDM_UC u_OFDM_UC (.clk(clk),
                     .reset(reset),
                     .clk_enable(clk_enable),
                     .modTypeIndex(modTypeIndex),  // ufix2
                     .codeRateIndex(codeRateIndex),  // ufix2
                     .data(data),
                     .valid(valid),
                     .ce_out_0(ce_out_0),
                     .ce_out_1(ce_out_1),
                     .txValid(txValid),
                     .txData_re(txData_re),  // sfix16_En13
                     .txData_im(txData_im),  // sfix16_En13
                     .Out3(Out3),
                     .Out4_re(Out4_re),  // sfix18_En16
                     .Out4_im(Out4_im),  // sfix18_En16
                     .ready(ready)
                     );

  assign txValid_enb = ce_out_0 & txValid_active;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 12663
  always @(posedge clk or posedge reset)
    begin : c_4_process
      if (reset == 1'b1) begin
        txValid_addr <= 14'b00000000000000;
      end
      else begin
        if (txValid_enb) begin
          if (txValid_addr >= 14'b11000101110111) begin
            txValid_addr <= 14'b00000000000000;
          end
          else begin
            txValid_addr <= txValid_addr + 14'b00000000000001;
          end
        end
      end
    end



  assign txValid_lastAddr = txValid_addr >= 14'b11000101110111;



  assign txValid_done = txValid_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_1
      if (reset) begin
        check1_done <= 0;
      end
      else begin
        if (txValid_done_enb) begin
          check1_done <= txValid_done;
        end
      end
    end

  assign snkDone = check5_done & (check4_done & (check3_done & (check1_done & check2_done)));



  assign #1 txValid_addr_delay_1 = txValid_addr;

  // Data source for txValid_expected
  initial
    begin : txValid_expected_fileread
      fp_txValid_expected = $fopen("txValid_expected.dat", "r");
      status_txValid_expected = $rewind(fp_txValid_expected);
    end

  always @(txValid_addr_delay_1,  tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        txValid_expected <= 1'bx;
      end
      else  begin
        status_txValid_expected = $fscanf(fp_txValid_expected, "%h", txValid_expected);
      end
    end

  // Bypass register to hold txValid_ref
  always @(posedge clk or posedge reset)
    begin : DataHold_txValid_ref
      if (reset) begin
        txValid_ref_hold <= 0;
      end
      else begin
        if (ce_out_0) begin
          txValid_ref_hold <= txValid_expected;
        end
      end
    end

  assign txValid_refTmp = txValid_expected;

  assign txValid_ref = (ce_out_0 == 1'b0 ? txValid_ref_hold :
              txValid_refTmp);



  always @(posedge clk or posedge reset)
    begin : txValid_checker
      if (reset == 1'b1) begin
        txValid_testFailure <= 1'b0;
      end
      else begin
        if (ce_out_0 == 1'b1 && txValid !== txValid_ref) begin
          txValid_testFailure <= 1'b1;
          $display("ERROR in txValid at time %t : Expected '%h' Actual '%h'", $time, txValid_ref, txValid);
        end
      end
    end

  assign #1 txData_re_addr_delay_1 = txValid_addr;

  // Data source for txData_re_expected
  initial
    begin : txData_re_expected_fileread
      fp_txData_re_expected = $fopen("txData_re_expected.dat", "r");
      status_txData_re_expected = $rewind(fp_txData_re_expected);
    end

  always @(txData_re_addr_delay_1,  tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        txData_re_expected <= 16'bx;
      end
      else  begin
        status_txData_re_expected = $fscanf(fp_txData_re_expected, "%h", txData_re_expected);
      end
    end

  // Bypass register to hold txData_re_ref
  always @(posedge clk or posedge reset)
    begin : DataHold_txData_re_ref
      if (reset) begin
        txData_re_ref_hold <= 0;
      end
      else begin
        if (ce_out_0) begin
          txData_re_ref_hold <= txData_re_expected;
        end
      end
    end

  assign txData_re_refTmp = txData_re_expected;

  assign txData_re_ref = (ce_out_0 == 1'b0 ? txData_re_ref_hold :
              txData_re_refTmp);



  always @(posedge clk or posedge reset)
    begin : txData_re_checker
      if (reset == 1'b1) begin
        txData_re_testFailure <= 1'b0;
      end
      else begin
        if (ce_out_0 == 1'b1 && txData_re !== txData_re_ref) begin
          txData_re_testFailure <= 1'b1;
          $display("ERROR in txData_re at time %t : Expected '%h' Actual '%h'", $time, txData_re_ref, txData_re);
        end
      end
    end

  // Data source for txData_im_expected
  initial
    begin : txData_im_expected_fileread
      fp_txData_im_expected = $fopen("txData_im_expected.dat", "r");
      status_txData_im_expected = $rewind(fp_txData_im_expected);
    end

  always @(txData_re_addr_delay_1,  tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        txData_im_expected <= 16'bx;
      end
      else  begin
        status_txData_im_expected = $fscanf(fp_txData_im_expected, "%h", txData_im_expected);
      end
    end

  // Bypass register to hold txData_im_ref
  always @(posedge clk or posedge reset)
    begin : DataHold_txData_im_ref
      if (reset) begin
        txData_im_ref_hold <= 0;
      end
      else begin
        if (ce_out_0) begin
          txData_im_ref_hold <= txData_im_expected;
        end
      end
    end

  assign txData_im_refTmp = txData_im_expected;

  assign txData_im_ref = (ce_out_0 == 1'b0 ? txData_im_ref_hold :
              txData_im_refTmp);



  always @(posedge clk or posedge reset)
    begin : txData_im_checker
      if (reset == 1'b1) begin
        txData_im_testFailure <= 1'b0;
      end
      else begin
        if (ce_out_0 == 1'b1 && txData_im !== txData_im_ref) begin
          txData_im_testFailure <= 1'b1;
          $display("ERROR in txData_im at time %t : Expected '%h' Actual '%h'", $time, txData_im_ref, txData_im);
        end
      end
    end

  assign #1 Out3_addr_delay_1 = txValid_addr;

  // Data source for Out3_expected
  initial
    begin : Out3_expected_fileread
      fp_Out3_expected = $fopen("Out3_expected.dat", "r");
      status_Out3_expected = $rewind(fp_Out3_expected);
    end

  always @(Out3_addr_delay_1,  tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        Out3_expected <= 1'bx;
      end
      else  begin
        status_Out3_expected = $fscanf(fp_Out3_expected, "%h", Out3_expected);
      end
    end

  // Bypass register to hold Out3_ref
  always @(posedge clk or posedge reset)
    begin : DataHold_Out3_ref
      if (reset) begin
        Out3_ref_hold <= 0;
      end
      else begin
        if (ce_out_0) begin
          Out3_ref_hold <= Out3_expected;
        end
      end
    end

  assign Out3_refTmp = Out3_expected;

  assign Out3_ref = (ce_out_0 == 1'b0 ? Out3_ref_hold :
              Out3_refTmp);



  always @(posedge clk or posedge reset)
    begin : Out3_checker
      if (reset == 1'b1) begin
        Out3_testFailure <= 1'b0;
      end
      else begin
        if (ce_out_0 == 1'b1 && Out3 !== Out3_ref) begin
          Out3_testFailure <= 1'b1;
          $display("ERROR in Out3 at time %t : Expected '%h' Actual '%h'", $time, Out3_ref, Out3);
        end
      end
    end

  assign #1 Out4_re_addr_delay_1 = txValid_addr;

  // Data source for Out4_re_expected
  initial
    begin : Out4_re_expected_fileread
      fp_Out4_re_expected = $fopen("Out4_re_expected.dat", "r");
      status_Out4_re_expected = $rewind(fp_Out4_re_expected);
    end

  always @(Out4_re_addr_delay_1,  tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        Out4_re_expected <= 18'bx;
      end
      else  begin
        status_Out4_re_expected = $fscanf(fp_Out4_re_expected, "%h", Out4_re_expected);
      end
    end

  // Bypass register to hold Out4_re_ref
  always @(posedge clk or posedge reset)
    begin : DataHold_Out4_re_ref
      if (reset) begin
        Out4_re_ref_hold <= 0;
      end
      else begin
        if (ce_out_0) begin
          Out4_re_ref_hold <= Out4_re_expected;
        end
      end
    end

  assign Out4_re_refTmp = Out4_re_expected;

  assign Out4_re_ref = (ce_out_0 == 1'b0 ? Out4_re_ref_hold :
              Out4_re_refTmp);



  always @(posedge clk or posedge reset)
    begin : Out4_re_checker
      if (reset == 1'b1) begin
        Out4_re_testFailure <= 1'b0;
      end
      else begin
        if (ce_out_0 == 1'b1 && Out4_re !== Out4_re_ref) begin
          Out4_re_testFailure <= 1'b1;
          $display("ERROR in Out4_re at time %t : Expected '%h' Actual '%h'", $time, Out4_re_ref, Out4_re);
        end
      end
    end

  // Data source for Out4_im_expected
  initial
    begin : Out4_im_expected_fileread
      fp_Out4_im_expected = $fopen("Out4_im_expected.dat", "r");
      status_Out4_im_expected = $rewind(fp_Out4_im_expected);
    end

  always @(Out4_re_addr_delay_1,  tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        Out4_im_expected <= 18'bx;
      end
      else  begin
        status_Out4_im_expected = $fscanf(fp_Out4_im_expected, "%h", Out4_im_expected);
      end
    end

  // Bypass register to hold Out4_im_ref
  always @(posedge clk or posedge reset)
    begin : DataHold_Out4_im_ref
      if (reset) begin
        Out4_im_ref_hold <= 0;
      end
      else begin
        if (ce_out_0) begin
          Out4_im_ref_hold <= Out4_im_expected;
        end
      end
    end

  assign Out4_im_refTmp = Out4_im_expected;

  assign Out4_im_ref = (ce_out_0 == 1'b0 ? Out4_im_ref_hold :
              Out4_im_refTmp);



  always @(posedge clk or posedge reset)
    begin : Out4_im_checker
      if (reset == 1'b1) begin
        Out4_im_testFailure <= 1'b0;
      end
      else begin
        if (ce_out_0 == 1'b1 && Out4_im !== Out4_im_ref) begin
          Out4_im_testFailure <= 1'b1;
          $display("ERROR in Out4_im at time %t : Expected '%h' Actual '%h'", $time, Out4_im_ref, Out4_im);
        end
      end
    end

  assign #1 ready_addr_delay_1 = ready_addr;

  // Data source for ready_expected
  initial
    begin : ready_expected_fileread
      fp_ready_expected = $fopen("ready_expected.dat", "r");
      status_ready_expected = $rewind(fp_ready_expected);
    end

  always @(ready_addr_delay_1,  tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        ready_expected <= 1'bx;
      end
      else  begin
        status_ready_expected = $fscanf(fp_ready_expected, "%h", ready_expected);
      end
    end

  // Bypass register to hold ready_ref
  always @(posedge clk or posedge reset)
    begin : DataHold_ready_ref
      if (reset) begin
        ready_ref_hold <= 0;
      end
      else begin
        if (ce_out_1) begin
          ready_ref_hold <= ready_expected;
        end
      end
    end

  assign ready_refTmp = ready_expected;

  assign ready_ref = (ce_out_1 == 1'b0 ? ready_ref_hold :
              ready_refTmp);



  always @(posedge clk or posedge reset)
    begin : ready_checker
      if (reset == 1'b1) begin
        ready_testFailure <= 1'b0;
      end
      else begin
        if (ce_out_1 == 1'b1 && ready !== ready_ref) begin
          ready_testFailure <= 1'b1;
          $display("ERROR in ready at time %t : Expected '%h' Actual '%h'", $time, ready_ref, ready);
        end
      end
    end

  assign testFailure = ready_testFailure | (Out4_im_testFailure | (Out4_re_testFailure | (Out3_testFailure | (txData_im_testFailure | (txValid_testFailure | txData_re_testFailure)))));



  always @(posedge clk)
    begin : completed_msg
      if (snkDone == 1'b1) begin
        if (testFailure == 1'b0) begin
          $display("**************TEST COMPLETED (PASSED)**************");
        end
        else begin
          $display("**************TEST COMPLETED (FAILED)**************");
        end
      end
    end

endmodule  // OFDM_UC_tb

