// -------------------------------------------------------------
// 
// File Name: hdlsrc_v\DUCforLTEHDL\Lowpass_Interpolator.v
// Created: 2023-02-09 10:49:26
// 
// Generated by MATLAB 9.13 and HDL Coder 4.0
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Lowpass_Interpolator
// Source Path: DUCforLTEHDL/HDL_DUC/Lowpass Interpolator
// Hierarchy Level: 1
// 
// HDLFIRInterpolation
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Lowpass_Interpolator
          (clk,
           reset,
           enb,
           dataIn,
           validIn,
           dataOut,
           validOut);


  input   clk;
  input   reset;
  input   enb;
  input   signed [15:0] dataIn;  // sfix16_En15
  input   validIn;
  output  signed [17:0] dataOut;  // sfix18_En14
  output  validOut;


  wire syncReset;
  wire signed [17:0] FIROutput2;  // sfix18_En14
  wire FIRValid2;
  wire outputSharingRSTTerm2;
  wire sharingReset;
  wire counterRST;
  wire validSharing;
  reg  sharingSEL_1;  // ufix1
  wire SharingSEL0;
  wire SharingCount0;
  wire outputSharingRSTTerm1;
  wire outputSharingRSTTerm3;
  reg  outputSharing_1;
  wire counterEnTerm;
  wire counterEn;
  reg [2:0] sharingCounter_1;  // ufix3
  wire validOutTerm;
  reg  validOut_1;
  wire signed [17:0] dataZero;  // sfix18_En14
  reg  sharingSELREG;  // ufix1
  wire signed [17:0] FIROutput1;  // sfix18_En14
  wire FIRValid1;
  reg  [0:3] intdelay_reg;  // ufix1 [4]
  wire [0:3] intdelay_reg_next;  // ufix1 [4]
  wire ValidPipeline1;
  reg signed [17:0] intdelay_reg_1 [0:3];  // sfix18 [4]
  wire signed [17:0] intdelay_reg_next_1 [0:3];  // sfix18_En14 [4]
  wire signed [17:0] FIROutputCastDBP1;  // sfix18_En14
  reg signed [17:0] FIROutputCastDB1;  // sfix18_En14
  reg signed [17:0] FIROutputCastDB2;  // sfix18_En14
  wire signed [17:0] dataSelect;  // sfix18_En14


  assign syncReset = 1'b0;



  FIRFilter2_block1 u_filterInstantiation (.clk(clk),
                                           .reset(reset),
                                           .enb(enb),
                                           .dataIn(dataIn),  // sfix16_En15
                                           .validIn(validIn),
                                           .dataOut(FIROutput2),  // sfix18_En14
                                           .validOut(FIRValid2)
                                           );

  assign outputSharingRSTTerm2 =  ~ FIRValid2;



  assign counterRST =  ~ sharingReset;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 1
  always @(posedge clk or posedge reset)
    begin : SharingSEL_process
      if (reset == 1'b1) begin
        sharingSEL_1 <= 1'b0;
      end
      else begin
        if (enb && validSharing) begin
          sharingSEL_1 <=  ~ sharingSEL_1;
        end
      end
    end



  assign SharingSEL0 = sharingSEL_1 == 1'b0;



  assign outputSharingRSTTerm1 = SharingCount0 & SharingSEL0;



  assign outputSharingRSTTerm3 = outputSharingRSTTerm1 & outputSharingRSTTerm2;



  assign sharingReset = syncReset | outputSharingRSTTerm3;



  always @(posedge clk or posedge reset)
    begin : OutputSharing_process
      if (reset == 1'b1) begin
        outputSharing_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          if (sharingReset == 1'b1) begin
            outputSharing_1 <= 1'b0;
          end
          else begin
            if (FIRValid2) begin
              outputSharing_1 <= FIRValid2;
            end
          end
        end
      end
    end



  assign counterEnTerm = outputSharing_1 | FIRValid2;



  assign counterEn = counterEnTerm & counterRST;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 7
  always @(posedge clk or posedge reset)
    begin : SharingCounter_process
      if (reset == 1'b1) begin
        sharingCounter_1 <= 3'b000;
      end
      else begin
        if (enb && counterEn) begin
          sharingCounter_1 <= sharingCounter_1 + 3'b001;
        end
      end
    end



  assign SharingCount0 = sharingCounter_1 == 3'b000;



  assign validSharing = SharingCount0 & counterEn;



  assign validOutTerm = validSharing | FIRValid2;



  always @(posedge clk or posedge reset)
    begin : OutputSharing_2_process
      if (reset == 1'b1) begin
        validOut_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          if (syncReset == 1'b1) begin
            validOut_1 <= 1'b0;
          end
          else begin
            validOut_1 <= validOutTerm;
          end
        end
      end
    end



  assign dataZero = 18'sb000000000000000000;



  always @(posedge clk or posedge reset)
    begin : OutputSharing_3_process
      if (reset == 1'b1) begin
        sharingSELREG <= 1'b0;
      end
      else begin
        if (enb) begin
          if (syncReset == 1'b1) begin
            sharingSELREG <= 1'b0;
          end
          else begin
            if (validSharing) begin
              sharingSELREG <= sharingSEL_1;
            end
          end
        end
      end
    end



  FIRFilter1_block1 u_filterInstantiation_1 (.clk(clk),
                                             .reset(reset),
                                             .enb(enb),
                                             .dataIn(dataIn),  // sfix16_En15
                                             .validIn(validIn),
                                             .dataOut(FIROutput1),  // sfix18_En14
                                             .validOut(FIRValid1)
                                             );

  always @(posedge clk or posedge reset)
    begin : intdelay_process
      if (reset == 1'b1) begin
        intdelay_reg[0] <= 1'b0;
        intdelay_reg[1] <= 1'b0;
        intdelay_reg[2] <= 1'b0;
        intdelay_reg[3] <= 1'b0;
      end
      else begin
        if (enb) begin
          if (syncReset == 1'b1) begin
            intdelay_reg[0] <= 1'b0;
            intdelay_reg[1] <= 1'b0;
            intdelay_reg[2] <= 1'b0;
            intdelay_reg[3] <= 1'b0;
          end
          else begin
            intdelay_reg[0] <= intdelay_reg_next[0];
            intdelay_reg[1] <= intdelay_reg_next[1];
            intdelay_reg[2] <= intdelay_reg_next[2];
            intdelay_reg[3] <= intdelay_reg_next[3];
          end
        end
      end
    end

  assign ValidPipeline1 = intdelay_reg[3];
  assign intdelay_reg_next[0] = FIRValid1;
  assign intdelay_reg_next[1] = intdelay_reg[0];
  assign intdelay_reg_next[2] = intdelay_reg[1];
  assign intdelay_reg_next[3] = intdelay_reg[2];



  always @(posedge clk or posedge reset)
    begin : intdelay_1_process
      if (reset == 1'b1) begin
        intdelay_reg_1[0] <= 18'sb000000000000000000;
        intdelay_reg_1[1] <= 18'sb000000000000000000;
        intdelay_reg_1[2] <= 18'sb000000000000000000;
        intdelay_reg_1[3] <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          if (syncReset == 1'b1) begin
            intdelay_reg_1[0] <= 18'sb000000000000000000;
            intdelay_reg_1[1] <= 18'sb000000000000000000;
            intdelay_reg_1[2] <= 18'sb000000000000000000;
            intdelay_reg_1[3] <= 18'sb000000000000000000;
          end
          else begin
            intdelay_reg_1[0] <= intdelay_reg_next_1[0];
            intdelay_reg_1[1] <= intdelay_reg_next_1[1];
            intdelay_reg_1[2] <= intdelay_reg_next_1[2];
            intdelay_reg_1[3] <= intdelay_reg_next_1[3];
          end
        end
      end
    end

  assign FIROutputCastDBP1 = intdelay_reg_1[3];
  assign intdelay_reg_next_1[0] = FIROutput1;
  assign intdelay_reg_next_1[1] = intdelay_reg_1[0];
  assign intdelay_reg_next_1[2] = intdelay_reg_1[1];
  assign intdelay_reg_next_1[3] = intdelay_reg_1[2];



  always @(posedge clk or posedge reset)
    begin : intdelay_2_process
      if (reset == 1'b1) begin
        FIROutputCastDB1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          if (syncReset == 1'b1) begin
            FIROutputCastDB1 <= 18'sb000000000000000000;
          end
          else begin
            if (ValidPipeline1) begin
              FIROutputCastDB1 <= FIROutputCastDBP1;
            end
          end
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : intdelay_3_process
      if (reset == 1'b1) begin
        FIROutputCastDB2 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          if (syncReset == 1'b1) begin
            FIROutputCastDB2 <= 18'sb000000000000000000;
          end
          else begin
            if (FIRValid2) begin
              FIROutputCastDB2 <= FIROutput2;
            end
          end
        end
      end
    end



  assign dataSelect = (sharingSELREG == 1'b0 ? FIROutputCastDB1 :
              FIROutputCastDB2);



  assign dataOut = (validOut_1 == 1'b0 ? dataZero :
              dataSelect);



  assign validOut = validOut_1;

endmodule  // Lowpass_Interpolator

